<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Cuadernos PDF</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --bg: #1a1a2e;
            --bg-secondary: #16213e;
            --accent: #0f3460;
            --text: #e8e8e8;
            --text-muted: #a0a0a0;
            --success: #4ecca3;
            --border: #2a2a4a;
            --error: #e74c3c;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .app-wrapper {
            display: flex;
            min-height: 100vh;
        }

        .main-content {
            flex: 1;
            padding: 2rem;
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        header p {
            color: var(--text-muted);
        }

        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 700px) {
            .panels {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
        }

        .panel h2 {
            font-size: 0.9rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.3rem;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 0.95rem;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--success);
        }

        input[type="number"]:invalid,
        input[type="number"].invalid {
            border-color: var(--error);
        }

        input[type="number"] {
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .input-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.2rem;
        }

        .input-hint.error {
            color: var(--error);
        }

        .description {
            background: var(--accent);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            min-height: 60px;
        }

        .description h3 {
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }

        .description p {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        button {
            padding: 0.8rem 2rem;
            font-size: 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.1s, opacity 0.1s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--success);
            color: var(--bg);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }

        .preview-info {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-top: 1rem;
        }

        .preview-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .preview-panel h2 {
            font-size: 0.9rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2a2a3a;
            border-radius: 4px;
            padding: 1rem;
            min-height: 300px;
        }

        #preview-canvas {
            background: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            height: auto;
        }

        .preview-size-info {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        /* ==================================================================
           SIDEBAR - Favorites
           ================================================================== */

        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: transform 300ms ease-in-out;
        }

        .sidebar-header {
            padding: 1.5rem 1rem 1rem;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-header h2 {
            font-size: 1rem;
            margin: 0;
            color: var(--success);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .sidebar-actions {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-actions .btn-save {
            width: 100%;
            padding: 0.7rem;
            background: var(--success);
            color: var(--bg);
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            margin-bottom: 0.5rem;
            transition: opacity 0.15s;
        }

        .sidebar-actions .btn-save:hover {
            opacity: 0.9;
        }

        .sidebar-actions-row {
            display: flex;
            gap: 0.5rem;
        }

        .sidebar-actions-row button {
            flex: 1;
            padding: 0.6rem;
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background 0.15s;
        }

        .sidebar-actions-row button:hover {
            background: var(--bg);
        }

        .favorites-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .favorite-item {
            background: var(--accent);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .favorite-item:hover {
            background: #1a4070;
            border-color: var(--success);
        }

        .favorite-item.active {
            border-color: var(--success);
            background: #1a4070;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .favorite-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
            color: var(--text);
            word-break: break-word;
        }

        .favorite-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.2rem;
        }

        .favorite-date {
            font-size: 0.7rem;
            color: var(--text-muted);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }

        .favorite-actions {
            display: flex;
            gap: 0.4rem;
        }

        .btn-icon {
            flex: 1;
            padding: 0.4rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.15s;
        }

        .btn-icon:hover {
            background: var(--bg-secondary);
            transform: scale(1.05);
        }

        .btn-icon.btn-danger:hover {
            background: var(--error);
            border-color: var(--error);
        }

        .favorites-empty {
            padding: 2rem 1rem;
            text-align: center;
            color: var(--text-muted);
        }

        .favorites-empty p {
            margin-bottom: 0.5rem;
        }

        .empty-hint {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* Mobile toggle button */
        .sidebar-toggle-btn {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1001;
            background: var(--success);
            color: var(--bg);
            border: none;
            border-radius: 6px;
            width: 44px;
            height: 44px;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 1000;
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-toggle-btn {
                display: block;
            }

            .main-content {
                padding: 1rem;
                padding-top: 4rem; /* Space for toggle button */
            }

            .panels {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-wrapper">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2>Favoritos</h2>
            </div>

            <div class="sidebar-actions">
                <button class="btn-save" onclick="saveFavoritePrompt()">‚≠ê Guardar actual</button>
                <div class="sidebar-actions-row">
                    <button class="btn-export" onclick="exportFavorites()" title="Exportar favoritos">üì§</button>
                    <button class="btn-import" onclick="document.getElementById('import-file').click()" title="Importar favoritos">üì•</button>
                    <input type="file" id="import-file" accept=".json" style="display:none" onchange="if(this.files[0]) importFavorites(this.files[0]); this.value='';">
                </div>
            </div>

            <div id="favorites-list" class="favorites-list"></div>

            <div id="favorites-empty" class="favorites-empty" style="display: none;">
                <p>No hay favoritos guardados</p>
                <p class="empty-hint">Configura tu cuaderno y guarda tus ajustes favoritos</p>
            </div>
        </aside>

        <!-- Mobile sidebar toggle -->
        <button class="sidebar-toggle-btn" onclick="toggleSidebar()" aria-label="Toggle favorites sidebar">
            ‚ò∞
        </button>

        <!-- Main content -->
        <div class="main-content">
            <div class="container">
                <header>
                    <h1>Generador de Cuadernos PDF</h1>
                    <p>Encuadernacion artesanal espanola</p>
                </header>

        <div class="panels">
            <div class="panel">
                <h2>Pagina</h2>

                <div class="form-group">
                    <label for="page_size">Tamano de pagina</label>
                    <select id="page_size" onchange="updateDescription(this)">
                        <option value="a5" data-desc="El mas popular para cuadernos artesanales. Tamano compacto ideal para llevar.">A5 (148x210mm)</option>
                        <option value="a4" data-desc="Tamano estandar de folio. Ideal para cuadernos de escritorio.">A4 (210x297mm)</option>
                        <option value="a6" data-desc="Tamano bolsillo. Perfecto para libretas de notas rapidas.">A6 (105x148mm)</option>
                        <option value="b5" data-desc="Intermedio entre A4 y A5. Popular en Japon y Corea.">B5 (176x250mm)</option>
                        <option value="letter" data-desc="Estandar estadounidense. Similar al A4.">Letter (216x279mm)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="orientation">Orientacion</label>
                    <select id="orientation" onchange="updateDescription(this)">
                        <option value="portrait" data-desc="Orientacion clasica de cuaderno. La mas comun para escritura.">Vertical (Portrait)</option>
                        <option value="landscape" data-desc="Orientacion apaisada. Ideal para dibujo y storyboards.">Horizontal (Landscape)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="pages">Numero de paginas</label>
                    <select id="pages" onchange="updateDescription(this)">
                        <option value="1" data-desc="Una sola pagina. Para pruebas o plantillas individuales.">1 pagina</option>
                        <option value="8" data-desc="Cuadernillo simple. Un solo pliego A4 doblado.">8 paginas</option>
                        <option value="16" data-desc="Dos pliegos. Libreta pequena.">16 paginas</option>
                        <option value="32" selected data-desc="Estandar para cuadernillos. Signature comun.">32 paginas</option>
                        <option value="48" data-desc="Tres signatures. Cuaderno mediano.">48 paginas</option>
                        <option value="64" data-desc="Cuatro signatures. Cuaderno completo.">64 paginas</option>
                        <option value="96" data-desc="Seis signatures. Cuaderno grueso.">96 paginas</option>
                        <option value="128" data-desc="Ocho signatures. Diario o journal.">128 paginas</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="pages_per_sheet">Paginas por hoja</label>
                    <select id="pages_per_sheet" onchange="updateDescription(this); toggleFoldLinesOption()">
                        <option value="1" data-desc="Una pagina por hoja. Sin imposicion.">1 pagina/hoja</option>
                        <option value="2" data-desc="Dos paginas lado a lado. Para doblar por la mitad.">2 paginas/hoja</option>
                        <option value="4" data-desc="Imposicion para cuadernillo. Saddle-stitch.">4 paginas/hoja</option>
                    </select>
                </div>
            </div>

            <div class="panel">
                <h2>Patron</h2>

                <div class="form-group">
                    <label for="pattern">Tipo de patron</label>
                    <select id="pattern" onchange="updateDescription(this)">
                        <option value="squared" data-desc="Patron de cuadrados. El mas versatil, muy popular en Espana.">Cuadricula</option>
                        <option value="lined" data-desc="Lineas horizontales para escritura. Pauta tradicional espanola.">Lineas</option>
                        <option value="dotted" data-desc="Rejilla de puntos. Popular para bullet journal y lettering.">Puntos</option>
                        <option value="blank" data-desc="Sin patron. Para dibujo libre y bocetos.">En blanco</option>
                        <option value="cornell" data-desc="Metodo de notas Cornell. Con columna de conceptos y resumen.">Cornell</option>
                        <option value="isometric" data-desc="Rejilla isometrica a 30 grados. Para dibujo tecnico y 3D.">Isometrico</option>
                        <option value="hexagonal" data-desc="Patron de hexagonos. Para quimica y diseno de juegos.">Hexagonal</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="spacing">Espaciado (mm)</label>
                    <select id="spacing" onchange="updateDescription(this)">
                        <option value="4" data-desc="Espaciado fino. Ideal para letra pequena o calculos.">4 mm</option>
                        <option value="5" selected data-desc="Estandar espanol para cuadricula. El mas comun.">5 mm</option>
                        <option value="6" data-desc="Espaciado medio. Bueno para escritura normal.">6 mm</option>
                        <option value="7" data-desc="Espaciado amplio. Comodo para notas rapidas.">7 mm</option>
                        <option value="8" data-desc="Pauta espanola estandar para lineas. Tradicional.">8 mm</option>
                        <option value="10" data-desc="Espaciado muy amplio. Para caligrafia o letra grande.">10 mm</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="line_gray">Color de linea</label>
                    <select id="line_gray" onchange="updateDescription(this)">
                        <option value="20" data-desc="Casi negro. Maxima visibilidad, para uso tecnico.">20% - Muy oscuro</option>
                        <option value="35" data-desc="Gris oscuro. Lineas muy marcadas.">35% - Oscuro</option>
                        <option value="50" data-desc="Gris medio. Lineas bien visibles, para lapiz.">50% - Medio</option>
                        <option value="65" data-desc="Buen contraste. Visibles pero no dominantes.">65% - Claro</option>
                        <option value="75" selected data-desc="Estandar espanol. Discretas pero visibles.">75% - Suave</option>
                        <option value="85" data-desc="Muy sutiles. Las lineas no compiten con la escritura.">85% - Muy claro</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="line_weight">Grosor de linea</label>
                    <select id="line_weight" onchange="updateDescription(this)">
                        <option value="0.2" data-desc="Lineas muy delicadas. Para papel de alta calidad.">0.2 pt - Ultrafino</option>
                        <option value="0.3" selected data-desc="Estandar para cuadernos de calidad.">0.3 pt - Fino</option>
                        <option value="0.4" data-desc="Grosor medio. Buena visibilidad.">0.4 pt - Normal</option>
                        <option value="0.5" data-desc="Lineas mas marcadas. Para patrones grandes.">0.5 pt - Grueso</option>
                        <option value="0.7" data-desc="Lineas prominentes. Alta visibilidad.">0.7 pt - Bold</option>
                        <option value="1.0" data-desc="Lineas muy gruesas. Para cuadriculas grandes o dibujo.">1.0 pt - Extra Bold</option>
                        <option value="1.5" data-desc="Lineas muy marcadas. Estilo cuaderno escolar.">1.5 pt - Ultra Bold</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="panels">
            <div class="panel">
                <h2>Margenes (mm)</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label for="margin_top">Superior</label>
                        <input type="number" id="margin_top" value="10" min="0.1" max="50" step="0.1" onchange="validateMargin(this)" oninput="validateMargin(this)">
                        <div class="input-hint">0.1-50 mm</div>
                    </div>
                    <div class="form-group">
                        <label for="margin_bottom">Inferior</label>
                        <input type="number" id="margin_bottom" value="10" min="0.1" max="50" step="0.1" onchange="validateMargin(this)" oninput="validateMargin(this)">
                        <div class="input-hint">0.1-50 mm</div>
                    </div>
                    <div class="form-group">
                        <label for="margin_left">Izquierdo</label>
                        <input type="number" id="margin_left" value="15" min="0.1" max="50" step="0.1" onchange="validateMargin(this)" oninput="validateMargin(this)">
                        <div class="input-hint">0.1-50 mm</div>
                    </div>
                    <div class="form-group">
                        <label for="margin_right">Derecho</label>
                        <input type="number" id="margin_right" value="10" min="0.1" max="50" step="0.1" onchange="validateMargin(this)" oninput="validateMargin(this)">
                        <div class="input-hint">0.1-50 mm</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Opciones adicionales</h2>
                <div class="form-group">
                    <label for="header_line">Linea de encabezado</label>
                    <select id="header_line">
                        <option value="no">Sin encabezado</option>
                        <option value="yes">Con encabezado</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="page_numbers">Numeros de pagina</label>
                    <select id="page_numbers">
                        <option value="no">Sin numerar</option>
                        <option value="yes">Numeradas</option>
                    </select>
                </div>
                <div class="form-group" id="fold_lines_group" style="display: none;">
                    <label for="fold_lines">Lineas de plegado</label>
                    <select id="fold_lines">
                        <option value="yes">Mostrar lineas de corte/plegado</option>
                        <option value="no">Sin lineas de corte/plegado</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="description" id="description-panel">
            <h3>Cuadricula</h3>
            <p>Patron de cuadrados. El mas versatil, muy popular en Espana.</p>
        </div>

        <div class="preview-panel">
            <h2>Vista previa</h2>
            <div class="preview-container">
                <canvas id="preview-canvas"></canvas>
            </div>
            <p class="preview-size-info" id="preview-size-info">A5 Portrait - 148 x 210 mm</p>
        </div>

        <div class="actions">
            <button class="btn-primary" id="generate-btn" onclick="generatePDF()">Generar PDF</button>
            <button class="btn-secondary" onclick="resetDefaults()">Restablecer</button>
        </div>

        <p class="preview-info">El PDF se descargara automaticamente</p>
            </div><!-- /.container -->
        </div><!-- /.main-content -->
    </div><!-- /.app-wrapper -->

    <script>
        const { jsPDF } = window.jspdf;

        // Page sizes in mm
        const PAGE_SIZES = {
            a4: [210, 297],
            a5: [148, 210],
            a6: [105, 148],
            b5: [176, 250],
            letter: [216, 279]
        };

        // ==================================================================
        // FAVORITES - LocalStorage Management
        // ==================================================================

        const STORAGE_KEY = 'notebook_favorites';

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function loadFavorites() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.error('Error loading favorites:', e);
                return [];
            }
        }

        function saveFavorites(favorites) {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(favorites));
                return true;
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    alert('Error: Espacio de almacenamiento lleno. Elimina algunos favoritos.');
                } else {
                    alert('Error al guardar favoritos.');
                }
                console.error('Error saving favorites:', e);
                return false;
            }
        }

        function addFavorite(name, config) {
            const favorites = loadFavorites();
            const favorite = {
                id: generateId(),
                name: name || 'Sin nombre',
                timestamp: Date.now(),
                config: config
            };
            favorites.push(favorite);
            if (saveFavorites(favorites)) {
                renderFavorites();
                return favorite.id;
            }
            return null;
        }

        function deleteFavorite(id) {
            const favorites = loadFavorites();
            const filtered = favorites.filter(f => f.id !== id);
            if (saveFavorites(filtered)) {
                renderFavorites();
                return true;
            }
            return false;
        }

        function duplicateFavorite(id) {
            const favorites = loadFavorites();
            const original = favorites.find(f => f.id === id);
            if (!original) return null;

            const copy = {
                id: generateId(),
                name: original.name + ' (Copia)',
                timestamp: Date.now(),
                config: { ...original.config }
            };
            favorites.push(copy);
            if (saveFavorites(favorites)) {
                renderFavorites();
                setTimeout(() => {
                    const element = document.getElementById('fav-' + copy.id);
                    if (element) element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
                return copy.id;
            }
            return null;
        }

        function loadFavorite(id) {
            const favorites = loadFavorites();
            const favorite = favorites.find(f => f.id === id);
            if (favorite) {
                setConfig(favorite.config);
                // Visual feedback
                const elements = document.querySelectorAll('.favorite-item');
                elements.forEach(el => el.classList.remove('active'));
                const element = document.getElementById('fav-' + id);
                if (element) {
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 2000);
                }
            }
        }

        function exportFavorites() {
            const favorites = loadFavorites();
            if (favorites.length === 0) {
                alert('No hay favoritos para exportar.');
                return;
            }

            const dataStr = JSON.stringify(favorites, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `notebook-favorites-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importFavorites(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!Array.isArray(imported)) {
                        throw new Error('Invalid format');
                    }

                    // Validate and merge
                    const current = loadFavorites();
                    const merged = [...current];
                    let imported_count = 0;

                    imported.forEach(fav => {
                        if (fav.config && fav.name) {
                            // Assign new ID to avoid conflicts
                            merged.push({
                                id: generateId(),
                                name: fav.name,
                                timestamp: Date.now(),
                                config: fav.config
                            });
                            imported_count++;
                        }
                    });

                    if (saveFavorites(merged)) {
                        renderFavorites();
                        alert(`${imported_count} favoritos importados correctamente.`);
                    }
                } catch (error) {
                    alert('Error: Archivo inv√°lido. Debe ser un archivo JSON v√°lido de favoritos.');
                    console.error('Import error:', error);
                }
            };
            reader.readAsText(file);
        }

        function saveFavoritePrompt() {
            const name = prompt('Nombre para esta configuraci√≥n:');
            if (name === null) return; // User cancelled
            if (name.trim() === '') {
                if (!confirm('¬øGuardar sin nombre?')) return;
            }

            const config = getConfig();
            const id = addFavorite(name.trim() || 'Sin nombre', config);
            if (id) {
                alert('Configuraci√≥n guardada!');
            }
        }

        function renderFavorites() {
            const favorites = loadFavorites();
            const container = document.getElementById('favorites-list');
            const emptyState = document.getElementById('favorites-empty');

            if (favorites.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            container.style.display = 'block';
            emptyState.style.display = 'none';

            // Sort by timestamp, newest first
            favorites.sort((a, b) => b.timestamp - a.timestamp);

            container.innerHTML = favorites.map(fav => {
                const date = new Date(fav.timestamp).toLocaleDateString('es-ES', {
                    day: '2-digit', month: 'short', year: 'numeric'
                });
                const pattern = fav.config.pattern || 'squared';
                const pageSize = (fav.config.page_size || 'a5').toUpperCase();
                const spacing = fav.config.spacing || 5;

                return `
                    <div class="favorite-item" id="fav-${fav.id}">
                        <div class="favorite-name">${escapeHtml(fav.name)}</div>
                        <div class="favorite-meta">${pattern} ¬∑ ${pageSize} ¬∑ ${spacing}mm</div>
                        <div class="favorite-date">${date}</div>
                        <div class="favorite-actions">
                            <button class="btn-icon" onclick="loadFavorite('${fav.id}')" title="Cargar">üìÇ</button>
                            <button class="btn-icon" onclick="duplicateFavorite('${fav.id}')" title="Duplicar">üìã</button>
                            <button class="btn-icon btn-danger" onclick="confirmDeleteFavorite('${fav.id}')" title="Eliminar">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function confirmDeleteFavorite(id) {
            const favorites = loadFavorites();
            const fav = favorites.find(f => f.id === id);
            if (!fav) return;

            if (confirm(`¬øEliminar "${fav.name}"?`)) {
                deleteFavorite(id);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        }

        // ==================================================================
        // END FAVORITES
        // ==================================================================

        function validateMargin(input) {
            const value = parseFloat(input.value);
            const min = parseFloat(input.min);
            const max = parseFloat(input.max);
            const hint = input.nextElementSibling;

            if (isNaN(value) || value < min || value > max) {
                input.classList.add('invalid');
                hint.classList.add('error');
                hint.textContent = `Debe ser entre ${min} y ${max} mm`;
                return false;
            } else {
                input.classList.remove('invalid');
                hint.classList.remove('error');
                hint.textContent = `${min}-${max} mm`;
                return true;
            }
        }

        function validateAllMargins() {
            const margins = ['margin_top', 'margin_bottom', 'margin_left', 'margin_right'];
            return margins.every(id => validateMargin(document.getElementById(id)));
        }

        function toggleFoldLinesOption() {
            const pagesPerSheet = parseInt(document.getElementById('pages_per_sheet').value);
            const foldLinesGroup = document.getElementById('fold_lines_group');
            foldLinesGroup.style.display = pagesPerSheet > 1 ? 'block' : 'none';
        }

        function getConfig() {
            const getMargin = (id, defaultValue) => {
                const value = parseFloat(document.getElementById(id).value);
                return isNaN(value) ? defaultValue : Math.max(0.1, value);
            };

            return {
                page_size: document.getElementById('page_size').value,
                orientation: document.getElementById('orientation').value,
                pattern: document.getElementById('pattern').value,
                spacing: parseFloat(document.getElementById('spacing').value),
                margin_top: getMargin('margin_top', 10),
                margin_bottom: getMargin('margin_bottom', 10),
                margin_left: getMargin('margin_left', 15),
                margin_right: getMargin('margin_right', 10),
                line_gray: parseInt(document.getElementById('line_gray').value),
                line_weight: parseFloat(document.getElementById('line_weight').value),
                pages: parseInt(document.getElementById('pages').value),
                pages_per_sheet: parseInt(document.getElementById('pages_per_sheet').value),
                header_line: document.getElementById('header_line').value,
                page_numbers: document.getElementById('page_numbers').value,
                fold_lines: document.getElementById('fold_lines').value
            };
        }

        function setConfig(config) {
            // Set all form values from config object
            if (config.page_size) document.getElementById('page_size').value = config.page_size;
            if (config.orientation) document.getElementById('orientation').value = config.orientation;
            if (config.pattern) document.getElementById('pattern').value = config.pattern;
            if (config.spacing) document.getElementById('spacing').value = config.spacing;
            if (config.margin_top !== undefined) document.getElementById('margin_top').value = config.margin_top;
            if (config.margin_bottom !== undefined) document.getElementById('margin_bottom').value = config.margin_bottom;
            if (config.margin_left !== undefined) document.getElementById('margin_left').value = config.margin_left;
            if (config.margin_right !== undefined) document.getElementById('margin_right').value = config.margin_right;
            if (config.line_gray) document.getElementById('line_gray').value = config.line_gray;
            if (config.line_weight) document.getElementById('line_weight').value = config.line_weight;
            if (config.pages) document.getElementById('pages').value = config.pages;
            if (config.pages_per_sheet) document.getElementById('pages_per_sheet').value = config.pages_per_sheet;
            if (config.header_line) document.getElementById('header_line').value = config.header_line;
            if (config.page_numbers) document.getElementById('page_numbers').value = config.page_numbers;
            if (config.fold_lines) document.getElementById('fold_lines').value = config.fold_lines;

            // Update UI after setting values
            updateDescription(document.getElementById('pattern'));
            ['margin_top', 'margin_bottom', 'margin_left', 'margin_right'].forEach(id => {
                validateMargin(document.getElementById(id));
            });
            toggleFoldLinesOption();
            updatePreview();
        }

        function updateDescription(selectElement) {
            const option = selectElement.options[selectElement.selectedIndex];
            const desc = option.dataset.desc;
            if (desc) {
                const panel = document.getElementById('description-panel');
                panel.innerHTML = `<h3>${option.text}</h3><p>${desc}</p>`;
            }
        }

        function resetDefaults() {
            document.getElementById('page_size').value = 'a5';
            document.getElementById('orientation').value = 'portrait';
            document.getElementById('pattern').value = 'squared';
            document.getElementById('spacing').value = '5';
            document.getElementById('margin_top').value = '10';
            document.getElementById('margin_bottom').value = '10';
            document.getElementById('margin_left').value = '15';
            document.getElementById('margin_right').value = '10';
            document.getElementById('line_gray').value = '75';
            document.getElementById('line_weight').value = '0.3';
            document.getElementById('pages').value = '32';
            document.getElementById('pages_per_sheet').value = '1';
            document.getElementById('header_line').value = 'no';
            document.getElementById('page_numbers').value = 'no';
            document.getElementById('fold_lines').value = 'yes';

            // Clear validation errors
            ['margin_top', 'margin_bottom', 'margin_left', 'margin_right'].forEach(id => {
                const input = document.getElementById(id);
                input.classList.remove('invalid');
                const hint = input.nextElementSibling;
                hint.classList.remove('error');
                hint.textContent = '0.1-50 mm';
            });

            toggleFoldLinesOption();
        }

        function getGrayColor(percent) {
            const val = Math.round(255 * percent / 100);
            return [val, val, val];
        }

        function drawLined(doc, x, y, width, height, config) {
            const spacing = config.spacing;
            const mt = config.margin_top;
            const mb = config.margin_bottom;
            const ml = config.margin_left;
            const mr = config.margin_right;

            doc.setDrawColor(...getGrayColor(config.line_gray));
            doc.setLineWidth(config.line_weight * 0.352778);

            // Calculate drawable height
            const drawableHeight = height - mt - mb;

            let headerOffset = 0;
            if (config.header_line === 'yes') {
                doc.setLineWidth(config.line_weight * 0.352778 * 1.5);
                doc.line(x + ml, y + mt, x + width - mr, y + mt);
                doc.setLineWidth(config.line_weight * 0.352778);
                headerOffset = spacing;
            }

            // Calculate number of complete lines that fit
            const availableHeight = drawableHeight - headerOffset;
            const numLines = Math.floor(availableHeight / spacing);

            // Calculate actual lines height
            const linesHeight = numLines * spacing;

            // Center vertically
            const offsetY = (availableHeight - linesHeight) / 2;
            const startY = y + mt + headerOffset + offsetY;

            // Draw lines
            for (let i = 1; i <= numLines; i++) {
                const lineY = startY + i * spacing;
                doc.line(x + ml, lineY, x + width - mr, lineY);
            }
        }

        function drawDotted(doc, x, y, width, height, config) {
            const spacing = config.spacing;
            const mt = config.margin_top;
            const mb = config.margin_bottom;
            const ml = config.margin_left;
            const mr = config.margin_right;
            const dotRadius = config.line_weight * 0.352778 * 0.6;

            doc.setFillColor(...getGrayColor(config.line_gray));

            // Calculate drawable area
            const drawableWidth = width - ml - mr;
            const drawableHeight = height - mt - mb;

            // Calculate number of complete dots that fit
            const numDotsX = Math.floor(drawableWidth / spacing) + 1;
            const numDotsY = Math.floor(drawableHeight / spacing) + 1;

            // Calculate actual grid size
            const gridWidth = (numDotsX - 1) * spacing;
            const gridHeight = (numDotsY - 1) * spacing;

            // Center the grid in the drawable area
            const offsetX = (drawableWidth - gridWidth) / 2;
            const offsetY = (drawableHeight - gridHeight) / 2;

            const startX = x + ml + offsetX;
            const startY = y + mt + offsetY;

            // Draw dots
            for (let i = 0; i < numDotsY; i++) {
                for (let j = 0; j < numDotsX; j++) {
                    const dotX = startX + j * spacing;
                    const dotY = startY + i * spacing;
                    doc.circle(dotX, dotY, dotRadius, 'F');
                }
            }
        }

        function drawSquared(doc, x, y, width, height, config) {
            const spacing = config.spacing;
            const mt = config.margin_top;
            const mb = config.margin_bottom;
            const ml = config.margin_left;
            const mr = config.margin_right;

            doc.setDrawColor(...getGrayColor(config.line_gray));
            doc.setLineWidth(config.line_weight * 0.352778);

            // Calculate drawable area
            const drawableWidth = width - ml - mr;
            const drawableHeight = height - mt - mb;

            // Calculate number of complete squares that fit
            const numSquaresX = Math.floor(drawableWidth / spacing);
            const numSquaresY = Math.floor(drawableHeight / spacing);

            // Calculate actual grid size
            const gridWidth = numSquaresX * spacing;
            const gridHeight = numSquaresY * spacing;

            // Center the grid in the drawable area
            const offsetX = (drawableWidth - gridWidth) / 2;
            const offsetY = (drawableHeight - gridHeight) / 2;

            const left = x + ml + offsetX;
            const right = left + gridWidth;
            const top = y + mt + offsetY;
            const bottom = top + gridHeight;

            // Draw vertical lines
            for (let i = 0; i <= numSquaresX; i++) {
                const lineX = left + i * spacing;
                doc.line(lineX, top, lineX, bottom);
            }

            // Draw horizontal lines
            for (let i = 0; i <= numSquaresY; i++) {
                const lineY = top + i * spacing;
                doc.line(left, lineY, right, lineY);
            }
        }

        function drawCornell(doc, x, y, width, height, config) {
            const ml = config.margin_left;
            const mr = config.margin_right;
            const mt = config.margin_top;
            const spacing = config.spacing;

            const cueWidth = width * 0.25;
            const summaryHeight = height * 0.15;

            doc.setDrawColor(...getGrayColor(config.line_gray));
            doc.setLineWidth(config.line_weight * 0.352778 * 2);

            doc.line(x + cueWidth, y + summaryHeight, x + cueWidth, y + height - mt);
            doc.line(x + ml, y + summaryHeight, x + width - mr, y + summaryHeight);

            doc.setLineWidth(config.line_weight * 0.352778);
            let lineY = y + mt + spacing;
            while (lineY < y + height - summaryHeight - mt) {
                doc.line(x + cueWidth + ml/2, lineY, x + width - mr, lineY);
                lineY += spacing;
            }
        }

        function drawIsometric(doc, x, y, width, height, config) {
            const spacing = config.spacing;
            const margin = config.margin_left;

            const left = x + margin;
            const right = x + width - margin;
            const top = y + margin;
            const bottom = y + height - margin;

            doc.setDrawColor(...getGrayColor(config.line_gray));
            doc.setLineWidth(config.line_weight * 0.352778);

            const angle = Math.PI / 6;
            const dy = spacing * Math.tan(angle);

            let lineY = top;
            while (lineY <= bottom) {
                doc.line(left, lineY, right, lineY);
                lineY += dy * 2;
            }

            const diagHeight = bottom - top;
            const diagRun = diagHeight / Math.tan(angle);

            for (let startX = left; startX <= right + diagRun; startX += spacing) {
                let x1 = startX;
                let y1 = bottom;
                let x2 = startX - diagRun;
                let y2 = top;

                if (x2 < left) {
                    y2 = bottom - (startX - left) * Math.tan(angle);
                    x2 = left;
                }
                if (x1 > right) {
                    y1 = bottom - (startX - right) * Math.tan(angle);
                    x1 = right;
                }
                if (y1 >= top && y2 <= bottom) {
                    doc.line(x1, y1, x2, y2);
                }
            }

            for (let startX = left - diagRun; startX <= right; startX += spacing) {
                let x1 = startX;
                let y1 = bottom;
                let x2 = startX + diagRun;
                let y2 = top;

                if (x1 < left) {
                    y1 = bottom - (left - startX) * Math.tan(angle);
                    x1 = left;
                }
                if (x2 > right) {
                    y2 = bottom - (right - startX) * Math.tan(angle);
                    x2 = right;
                }
                if (y1 >= top && y2 <= bottom) {
                    doc.line(x1, y1, x2, y2);
                }
            }
        }

        function drawHexagon(doc, cx, cy, size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                points.push([
                    cx + size * Math.cos(angle),
                    cy + size * Math.sin(angle)
                ]);
            }

            doc.lines(
                points.slice(1).map((p, i) => [p[0] - points[i][0], p[1] - points[i][1]]),
                points[0][0], points[0][1],
                [1, 1], 'S', true
            );
        }

        function drawHexagonal(doc, x, y, width, height, config) {
            const size = config.spacing;
            const mt = config.margin_top;
            const mb = config.margin_bottom;
            const ml = config.margin_left;
            const mr = config.margin_right;

            doc.setDrawColor(...getGrayColor(config.line_gray));
            doc.setLineWidth(config.line_weight * 0.352778);

            // For pointy-top hexagons (rotated by -30¬∞)
            const hexWidth = size * Math.sqrt(3);  // flat-to-flat width (horizontal)
            const hexHeight = 2 * size;             // point-to-point height (vertical)

            // Honeycomb tiling: hexagons touch edge-to-edge
            const horizontalSpacing = hexWidth;       // center-to-center horizontal
            const verticalSpacing = hexHeight * 0.75; // center-to-center vertical (3/4 of height)
            const rowOffset = hexWidth * 0.5;         // horizontal shift for odd rows

            let row = 0;
            let hexY = y + mt + size;
            while (hexY < y + height - mb - size) {
                const offset = (row % 2) ? rowOffset : 0;
                let hexX = x + ml + hexWidth / 2 + offset;
                while (hexX < x + width - mr - hexWidth / 2) {
                    drawHexagon(doc, hexX, hexY, size);
                    hexX += horizontalSpacing;
                }
                hexY += verticalSpacing;
                row++;
            }
        }

        function drawPattern(doc, x, y, width, height, config) {
            const patterns = {
                lined: drawLined,
                dotted: drawDotted,
                squared: drawSquared,
                cornell: drawCornell,
                isometric: drawIsometric,
                hexagonal: drawHexagonal,
                blank: () => {}
            };

            const drawFn = patterns[config.pattern] || patterns.squared;
            drawFn(doc, x, y, width, height, config);
        }

        function drawPageNumber(doc, pageWidth, pageHeight, pageNum, config) {
            doc.setFontSize(8);
            doc.setTextColor(128, 128, 128);

            const x = (pageNum % 2 === 0) ? config.margin_left : pageWidth - config.margin_right;
            doc.text(String(pageNum), x, pageHeight - config.margin_bottom / 2, {
                align: pageNum % 2 === 0 ? 'left' : 'right'
            });
        }

        function drawFoldLines(doc, pageWidth, pageHeight, pagesPerSheet, config) {
            if (config.fold_lines !== 'yes') return;

            doc.setDrawColor(230, 230, 230);
            doc.setLineWidth(0.1);
            doc.setLineDashPattern([2, 2], 0);

            if (pagesPerSheet === 2) {
                const halfWidth = pageWidth / 2;
                doc.line(halfWidth, 0, halfWidth, pageHeight);
            } else if (pagesPerSheet === 4) {
                const halfWidth = pageWidth / 2;
                const halfHeight = pageHeight / 2;
                doc.line(halfWidth, 0, halfWidth, pageHeight);
                doc.line(0, halfHeight, pageWidth, halfHeight);
            }

            doc.setLineDashPattern([], 0);
        }

        function generatePDF() {
            if (!validateAllMargins()) {
                alert('Por favor, corrige los valores de los margenes antes de generar el PDF.');
                return;
            }

            const config = getConfig();

            let [pageWidth, pageHeight] = PAGE_SIZES[config.page_size];
            if (config.orientation === 'landscape') {
                [pageWidth, pageHeight] = [pageHeight, pageWidth];
            }

            const doc = new jsPDF({
                orientation: config.orientation,
                unit: 'mm',
                format: [pageWidth, pageHeight]
            });

            const totalPages = config.pages;
            const pagesPerSheet = config.pages_per_sheet;
            const sheetsNeeded = Math.ceil(totalPages / pagesPerSheet);

            for (let sheet = 0; sheet < sheetsNeeded; sheet++) {
                if (sheet > 0) doc.addPage();

                const startPage = sheet * pagesPerSheet + 1;

                if (pagesPerSheet === 1) {
                    drawPattern(doc, 0, 0, pageWidth, pageHeight, config);
                    if (config.page_numbers === 'yes') {
                        drawPageNumber(doc, pageWidth, pageHeight, startPage, config);
                    }
                } else if (pagesPerSheet === 2) {
                    const halfWidth = pageWidth / 2;
                    drawPattern(doc, 0, 0, halfWidth, pageHeight, config);
                    drawPattern(doc, halfWidth, 0, halfWidth, pageHeight, config);
                    drawFoldLines(doc, pageWidth, pageHeight, pagesPerSheet, config);
                } else if (pagesPerSheet === 4) {
                    const halfWidth = pageWidth / 2;
                    const halfHeight = pageHeight / 2;

                    drawPattern(doc, 0, 0, halfWidth, halfHeight, config);
                    drawPattern(doc, halfWidth, 0, halfWidth, halfHeight, config);
                    drawPattern(doc, 0, halfHeight, halfWidth, halfHeight, config);
                    drawPattern(doc, halfWidth, halfHeight, halfWidth, halfHeight, config);
                    drawFoldLines(doc, pageWidth, pageHeight, pagesPerSheet, config);
                }
            }

            const filename = `cuaderno_${config.pattern}_${config.page_size}_${config.pages}pag.pdf`;
            doc.save(filename);
        }

        // Preview rendering
        const PREVIEW_MAX_HEIGHT = 280;
        const PREVIEW_SCALE = 1.5; // pixels per mm

        function updatePreview() {
            const config = getConfig();
            const canvas = document.getElementById('preview-canvas');
            const ctx = canvas.getContext('2d');

            // Get page dimensions in mm
            let [pageWidth, pageHeight] = PAGE_SIZES[config.page_size];
            if (config.orientation === 'landscape') {
                [pageWidth, pageHeight] = [pageHeight, pageWidth];
            }

            // Calculate scale to fit preview
            const scale = Math.min(PREVIEW_MAX_HEIGHT / pageHeight, (400) / pageWidth) * PREVIEW_SCALE;

            // Set canvas size
            canvas.width = pageWidth * scale;
            canvas.height = pageHeight * scale;

            // Clear and fill white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pattern based on pages per sheet
            const pagesPerSheet = config.pages_per_sheet;

            if (pagesPerSheet === 1) {
                drawPreviewPattern(ctx, 0, 0, canvas.width, canvas.height, config, scale);
            } else if (pagesPerSheet === 2) {
                const halfWidth = canvas.width / 2;
                drawPreviewPattern(ctx, 0, 0, halfWidth, canvas.height, config, scale);
                drawPreviewPattern(ctx, halfWidth, 0, halfWidth, canvas.height, config, scale);

                if (config.fold_lines === 'yes') {
                    ctx.strokeStyle = '#e6e6e6';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(halfWidth, 0);
                    ctx.lineTo(halfWidth, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            } else if (pagesPerSheet === 4) {
                const halfWidth = canvas.width / 2;
                const halfHeight = canvas.height / 2;

                drawPreviewPattern(ctx, 0, 0, halfWidth, halfHeight, config, scale);
                drawPreviewPattern(ctx, halfWidth, 0, halfWidth, halfHeight, config, scale);
                drawPreviewPattern(ctx, 0, halfHeight, halfWidth, halfHeight, config, scale);
                drawPreviewPattern(ctx, halfWidth, halfHeight, halfWidth, halfHeight, config, scale);

                if (config.fold_lines === 'yes') {
                    ctx.strokeStyle = '#e6e6e6';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(halfWidth, 0);
                    ctx.lineTo(halfWidth, canvas.height);
                    ctx.moveTo(0, halfHeight);
                    ctx.lineTo(canvas.width, halfHeight);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Update size info
            const sizeInfo = document.getElementById('preview-size-info');
            const orientationText = config.orientation === 'portrait' ? 'Vertical' : 'Horizontal';
            sizeInfo.textContent = `${config.page_size.toUpperCase()} ${orientationText} - ${pageWidth} x ${pageHeight} mm`;
        }

        function drawPreviewPattern(ctx, x, y, width, height, config, scale) {
            const pattern = config.pattern;
            const spacing = config.spacing * scale;
            const mt = config.margin_top * scale;
            const mb = config.margin_bottom * scale;
            const ml = config.margin_left * scale;
            const mr = config.margin_right * scale;

            const grayValue = Math.round(255 * config.line_gray / 100);
            const grayColor = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
            const lineWidth = Math.max(0.5, config.line_weight * scale * 0.3);

            ctx.strokeStyle = grayColor;
            ctx.fillStyle = grayColor;
            ctx.lineWidth = lineWidth;

            const left = x + ml;
            const right = x + width - mr;
            const top = y + mt;
            const bottom = y + height - mb;

            if (pattern === 'blank') {
                return;
            }

            if (pattern === 'lined') {
                // Calculate drawable height
                const drawableHeight = height - mt - mb;

                let headerOffset = 0;
                if (config.header_line === 'yes') {
                    ctx.lineWidth = lineWidth * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(left, top);
                    ctx.lineTo(right, top);
                    ctx.stroke();
                    ctx.lineWidth = lineWidth;
                    headerOffset = spacing;
                }

                // Calculate number of complete lines
                const availableHeight = drawableHeight - headerOffset;
                const numLines = Math.floor(availableHeight / spacing);

                // Calculate actual lines height
                const linesHeight = numLines * spacing;

                // Center vertically
                const offsetY = (availableHeight - linesHeight) / 2;
                const startY = top + headerOffset + offsetY;

                ctx.beginPath();
                for (let i = 1; i <= numLines; i++) {
                    const ly = startY + i * spacing;
                    ctx.moveTo(left, ly);
                    ctx.lineTo(right, ly);
                }
                ctx.stroke();
            }

            if (pattern === 'dotted') {
                const dotRadius = Math.max(0.5, lineWidth * 0.8);

                // Calculate drawable area
                const drawableWidth = width - ml - mr;
                const drawableHeight = height - mb - mt;

                // Calculate number of complete dots
                const numDotsX = Math.floor(drawableWidth / spacing) + 1;
                const numDotsY = Math.floor(drawableHeight / spacing) + 1;

                // Calculate actual grid size
                const gridWidth = (numDotsX - 1) * spacing;
                const gridHeight = (numDotsY - 1) * spacing;

                // Center the grid
                const offsetX = (drawableWidth - gridWidth) / 2;
                const offsetY = (drawableHeight - gridHeight) / 2;

                const startX = left + offsetX;
                const startY = top + offsetY;

                for (let i = 0; i < numDotsY; i++) {
                    for (let j = 0; j < numDotsX; j++) {
                        const dx = startX + j * spacing;
                        const dy = startY + i * spacing;
                        ctx.beginPath();
                        ctx.arc(dx, dy, dotRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            if (pattern === 'squared') {
                // Calculate drawable area
                const drawableWidth = width - ml - mr;
                const drawableHeight = height - mb - mt;

                // Calculate number of complete squares
                const numSquaresX = Math.floor(drawableWidth / spacing);
                const numSquaresY = Math.floor(drawableHeight / spacing);

                // Calculate actual grid size
                const gridWidth = numSquaresX * spacing;
                const gridHeight = numSquaresY * spacing;

                // Center the grid
                const offsetX = (drawableWidth - gridWidth) / 2;
                const offsetY = (drawableHeight - gridHeight) / 2;

                const gridLeft = left + offsetX;
                const gridRight = gridLeft + gridWidth;
                const gridTop = top + offsetY;
                const gridBottom = gridTop + gridHeight;

                ctx.beginPath();
                // Vertical lines
                for (let i = 0; i <= numSquaresX; i++) {
                    const lx = gridLeft + i * spacing;
                    ctx.moveTo(lx, gridTop);
                    ctx.lineTo(lx, gridBottom);
                }
                // Horizontal lines
                for (let i = 0; i <= numSquaresY; i++) {
                    const ly = gridTop + i * spacing;
                    ctx.moveTo(gridLeft, ly);
                    ctx.lineTo(gridRight, ly);
                }
                ctx.stroke();
            }

            if (pattern === 'cornell') {
                const cueWidth = width * 0.25;
                const summaryHeight = height * 0.15;

                ctx.lineWidth = lineWidth * 2;
                ctx.beginPath();
                ctx.moveTo(x + cueWidth, y + summaryHeight);
                ctx.lineTo(x + cueWidth, y + height - mt);
                ctx.moveTo(x + ml, y + summaryHeight);
                ctx.lineTo(x + width - mr, y + summaryHeight);
                ctx.stroke();

                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                for (let ly = top + spacing; ly < y + height - summaryHeight - mt; ly += spacing) {
                    ctx.moveTo(x + cueWidth + ml/2, ly);
                    ctx.lineTo(right, ly);
                }
                ctx.stroke();
            }

            if (pattern === 'isometric') {
                const angle = Math.PI / 6;
                const dy = spacing * Math.tan(angle);

                ctx.beginPath();
                // Horizontal lines
                for (let ly = top; ly <= bottom; ly += dy * 2) {
                    ctx.moveTo(left, ly);
                    ctx.lineTo(right, ly);
                }
                ctx.stroke();

                // Diagonals (simplified for preview)
                const diagHeight = bottom - top;
                const diagRun = diagHeight / Math.tan(angle);

                ctx.beginPath();
                for (let startX = left; startX <= right + diagRun; startX += spacing) {
                    let x1 = startX, y1 = bottom;
                    let x2 = startX - diagRun, y2 = top;
                    if (x2 < left) { y2 = bottom - (startX - left) * Math.tan(angle); x2 = left; }
                    if (x1 > right) { y1 = bottom - (startX - right) * Math.tan(angle); x1 = right; }
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                }
                for (let startX = left - diagRun; startX <= right; startX += spacing) {
                    let x1 = startX, y1 = bottom;
                    let x2 = startX + diagRun, y2 = top;
                    if (x1 < left) { y1 = bottom - (left - startX) * Math.tan(angle); x1 = left; }
                    if (x2 > right) { y2 = bottom - (right - startX) * Math.tan(angle); x2 = right; }
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                }
                ctx.stroke();
            }

            if (pattern === 'hexagonal') {
                const size = spacing / scale;  // Use actual spacing value from config

                // For pointy-top hexagons (rotated by -30¬∞)
                const hexWidth = size * Math.sqrt(3);   // flat-to-flat width (horizontal)
                const hexHeight = 2 * size;              // point-to-point height (vertical)

                // Honeycomb tiling: hexagons touch edge-to-edge
                const horizontalSpacing = hexWidth;       // center-to-center horizontal
                const verticalSpacing = hexHeight * 0.75; // center-to-center vertical (3/4 of height)
                const rowOffset = hexWidth * 0.5;         // horizontal shift for odd rows

                let row = 0;
                for (let hy = top + size; hy < bottom - size; hy += verticalSpacing) {
                    const offset = (row % 2) ? rowOffset : 0;
                    for (let hx = left + hexWidth / 2 + offset; hx < right - hexWidth / 2; hx += horizontalSpacing) {
                        drawPreviewHexagon(ctx, hx, hy, size);
                    }
                    row++;
                }
            }
        }

        function drawPreviewHexagon(ctx, cx, cy, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const x = cx + size * Math.cos(angle);
                const y = cy + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        // Add change listeners to all inputs
        function setupPreviewListeners() {
            const inputs = document.querySelectorAll('select, input');
            inputs.forEach(input => {
                input.addEventListener('change', updatePreview);
                input.addEventListener('input', updatePreview);
            });
        }

        // Initialize
        toggleFoldLinesOption();
        setupPreviewListeners();
        updatePreview();
        renderFavorites(); // Initialize favorites sidebar

        // Collapse sidebar on mobile by default
        if (window.innerWidth <= 768) {
            document.querySelector('.sidebar').classList.add('collapsed');
        }
    </script>
</body>
</html>
